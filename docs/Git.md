# Git

# Содержание

* [Начало работы](#начало-работы)
> * [Начальная настройка окружения](#начальная-настройка-окружения)
> * [Инициализация репозитория](#инициализация-репозитория)

* [Основы](#основы)
> * [Клонирование репозитория](#клонирование-репозитория)
> * [Просмотр текущего состояния ](#просмотр-текущего-состояния)
> * [Подробный просмотр файлов при изменении](#подробный-просмотр-файлов-при-изменении)
> * [Добавление в отслеживаемые файлы](#добавление-в-отслеживаемые-файлы)
> * [Фиксация изменений](#фиксация-изменений)
> * [Игнорирование файлов](#игнорирование-файлов)
> * [Удаление файлов](#удаление-файлов)
> * [Перемещение или переименовывание файлов](#перемещение-или-переименование-файлов)
> * [Просмотр истории коммитов](#просмотр-истории-коммитов)
> * [Работа с удалёнными репозиториями](#работа-с-удалёнными-репозиториями)
> * [Отправка данных на сервер](#отправка-данных-на-сервер)
> * [Скачивание данных с сервера](#скачивание-данных-с-сервера)
> * [Загрузка коммитов с сервера](#загрузка-коммитов-с-сервера)
> * [Тэги](#тэги)
> * [Псевдонимы](#псевдонимы)
> * [Настройка репозитория](#настройка-репозитория)

* [Ветвление](#ветвление)
> * [Создание и просмотр веток](#создание-и-просмотр-веток)
> * [Смена ветки](#смена-ветки)
> * [Слияние](#слияние)
> * [Перемещение](#перемещение)
> * [Сравнение слияния и перемещение веток](#сравнение-слияния-и-перемещение-веток)

* [Инструменты Git](#инструменты-git)
> * [Редактирование нескольких коммитов](#редактирование-нескольких-коммитов)
> * [Объединение коммитов](#объединение-коммитов)
> * [Изменение порядка следования коммитов](#изменение-порядка-следования-коммитов)
> * [Отмена коммитов](#отмена-коммитов)
> * [Отмена изменений при уже отправленном коммите](#отмена-изменений-при-уже-отправленном-коммите)
> * [Перенос указателя ветки](#перенос-указателя-ветки)
> * [Очистка проекта от лишних файлов](#очистка-проекта-от-лишних-файлов)
> * [Просмотр кто написал эту строку](#просмотр-кто-написал-эту-строку)
> * [Восстановление файла к определённому коммиту](#восстановление-файла-к-определённому-коммиту)
> * [Откладывание изменений](#откладывание-изменений)
> * [Копирование коммита](#копирование-коммита)
> * [Подключение к репозиторию по ssh](#подключение-к-репозиторию-по-ssh)
> * [Быстрый поиск плохого коммита](#быстрый-поиск-плохого-коммита)
> * [Отмена любых изменений](#отмена-любых-изменений)
> * [Подмодули](#подмодули)
> * [Подпись коммитов](#подпись-коммитов)
> * [Поиск по истории коммитов](#поиск-по-истории-коммитов)
> * [Повторное слияние](#повторное-слияние)


# Начало работы

## Начальная настройка окружения

Для начальной конфигурации репозитория требуется установить имя и email для репозитория.
Опция `--global` используется для настройки всех репозиториев текущего пользователя.

    git config --global user.name "<your-name>"
    git config --global user.email "<your-email>


## Инициализация репозитория

Инициализация репозитория git в текущей директории,
в результате будет специальная директория `.git` со всеми настройками git-репозитория.

    git init


# Основы

## Клонирование репозитория

Команда для клонирования репозитория с сервера.

    git clone <url>

Если требуется склонировать в другую директорию,
то вторым параметром указывается путь к директории.

    git clone <url> <path>

Для клонирования определённой ветки, нужно указать через флаг `-b`.

    git clone -b <branch-name> <url>


## Просмотр текущего состояния

Проверка текущего состояния всех файлов.

    git status

При любом изменении состояния файлов, и их содержимым,
*status* будет выдавать всю подробную информацию.

Если требуется получить краткий отчёт можно воспользоваться опцией `--short` или `-s`.

    git status -s

Так же рядом с файлами будут показаны в каком сейчас файлы формате.

* ?? - неотслеживаемый файл.
* A - добавлен в отслеживаемые файлы.
* M - модифицированный файл.
* D - удалённый файл.
* R - переименованный файл.


## Подробный просмотр файлов при изменении

Для просмотра изменений в файлах используется `diff`.

    git diff

Чтобы посмотреть что из проиндексированного войдёт в коммит.

    git diff --staged

Эта же команда покажет проиндексированные изменения.

    git diff --cached

Так же можно указать определённый файл который нужно посмотреть на изменения.

    git diff <file-name>

Проверка на наличие лишних пробелов в коде.
Очень хорошей практикой является запускать эту команду перед коммитом.

     git diff --check


## Добавление в отслеживаемые файлы

Для того чтобы начать отслеживать новый файл.

    git add <file-name>

Если же добавляется директория,
то все файлы находящиеся в ней будут так же добавлены в отслеживаемые.

Так же если требуется добавить все файлы.

    git add .

Если требуется просмотреть изменения в каждом файле по частям в виде исправлений,
прежде чем решать вносить их или нет.

    git add -p <path-file>
    git add -p .

* y - разместить этот фрагмент.
* n - не размещать этот фрагмент.
* q - выйти; не размещать этот фрагмент или любой из оставшихся.
* a - разместить этот фрагмент и все последующие фрагменты в файле.
* d - не размещать этот фрагмент и все последующие фрагменты в файле.
* e - вручную отредактировать текущий фрагмент.


## Фиксация изменений

После добавление изменений, можно зафиксировать внесённые изменения.

    git commit

После команды откроется текстовый редактор, установленный по умолчанию.
Где требуется дать комментарий коммиту.

Если нужна более подробная информация об изменениях.

    git commit -v

Так же можно задать сообщение об фиксации и в самой команде, без открытия текстового редактора.

    git commit -m "<comment>"

Выполнение коммита со всеми изменениями в рабочем каталоге.

    git commit -a

Изменение сообщения последнего коммита, при вводе открывается текстовый редактор.

    git commit --amend

Изменение сообщения последнего коммита, без редактора.

    git commit --amend -m "<new-comment>"

Так же если был сделан ранний коммит,
и при этом забыты какие-либо изменения, то можно их добавить.

    git commit -m "<old-commit>"
    git add <file-name>
    git commit --amend -m "<new-commit>"

Если был добавлен или изменён файл и при этом не требуется менять имя коммита.

    git commit --amend --no-edit


## Игнорирование файлов

Иногда нужно чтобы некоторые файлы, группа файлов, директории не добавлялись в репозиторий.
Обычно в эту категорию попадают автоматически генерируемые файлы.

Команда для создания такого файла.

    touch .gitignore

Составление `.gitignore` файла.

    # комментарий – это игнорируется
    *.a # пропускаются файлы, заканчивающиеся на .a
    *.[oa] # пропускаются файлы, заканчивающиеся на .a или .o
    !lib.a # при указанном *.a, файл lib.a, будет всё равно отслеживаться
    /file # игнорируется корневой файл
    build/ # игнорировать все файлы в этой директории
    doc/*.txt # игнорируются все файлы .txt в директории doc, но не в doc/.../file.txt
    dir/**/debug.log # ** - Две звездочки соответствуют множеству каталогов или ни одному

Так же можно найти список файлов
[.gitignore](https://github.com/github/gitignore) для языков и проектов.

Для просмотра файлов которые игнорируются в текущем проекте.

    git ls-files --others --ignored --exclude-standard

Можно создать глобальный gitignore.

    git config --global core.excludesFile ~/.gitignore


## Удаление файлов

Удаление из отслеживаемых файлов и директории.

    git rm <file-name>

Если требуется удалить из отслеживаемых файлов,
но не удалять с файловой системы, то нужно использовать опцию `--cached`.

    git rm --cached <file-name>

Если файл был изменён, но всё равно требуется его удалить,
то добавляется опция `--force` или `-f`.

    git rm -f <file-name>

Если нужно посмотреть какие файлы будут удалены,
но не удалять их, то используется опция `--dry-run` или `-n`.

    git rm --dry-run <file-name>


## Перемещение или переименование файлов

Переименование файла или директории.

    git mv <old-file-name> <new-file-name>

Перемещение файла или директории.

    git mv <file-name> <path-to-file-name>


## Просмотр истории коммитов

Команда для просмотра истории коммитов.
Первыми выводятся самые свежие коммиты.

    git log

Для того чтобы посмотреть только 3 последних коммита, нужно использовать опцию `-n`.

    git log -n <count-commits>

Для получения краткой характеристики используется опцию `--stat`.

    git log --stat

Самое подробное представление истории коммитов.

    git log -p

Показывает изменённые файлы в данном коммите.

    git log --name-status

Поиск по коммитам.

    git log --grep="<pattern>"

Показывает коммиты по определённому автору.

    git log --author="<author>"

Параметр `--pretty` определяет формат вывода информации.

    git log --pretty=oneline

Стандартные параметры для pretty.

* oneline
* short
* full
* fuller

Так же можно определять свой вывод информации.

    git log --pretty=format:"%h - %an, %ar : %s"

Самые распространённые параметры форматирования.

| Параметр   | Описание                                        |
|------------|:------------------------------------------------|
|         %H |                                 Хэш-код коммита |
|         %h |                     Сокращенный хэш-код коммита |
|         %T |                                  Хэш-код дерева |
|         %t |                      Сокращенный хэш-код дерева |
|         %P |                   Хэш-код родительских коммитов |
|         %p |       Сокращенный хэш-код родительских коммитов |
|        %an |                                      Имя автора |
|        %ae |                        Электронная почта автора |
|        %ad |                         Дата создания оригинала |
|        %ar |  Дата создания оригинала, в относительной форме |
|        %cn |                            Имя создателя версии |
|        %ce |                     Электронная почта создателя |
|        %cd |                            Дата создания версии |
|        %cr |    Дата создания версии в относительном формате |
|         %s |                                     Комментарий |


Вывод коммитов с историей ветвлений и слияний.

    git log --graph

Очень удобная команда, которая выводит дерево всех коммитов в дереве.

    git log --all --decorate --oneline --graph

Так же можно эту команду добавить в alias.

    git config --global alias.tree "log --all --decorate --oneline --graph"
    git tree

Для просмотра что было изменено в определённом коммите.

    git show <hash-commit>


## Работа с удалёнными репозиториями

Отображение удалённых репозиториев.

    git remote

Посмотреть адреса, для сокращенного имени.

    git remote -v

Создание нового подключения к удаленному репозиторию.

    git remote add <remote-server-name> <url>

Удаление подключения к удаленному репозиторию с именем.

    git remote rm <remote-server-name>

Переименование удаленного подключения с имени.

    git remote rename <old-name> <new-name>

Изменение адреса, для определённого имени.

    git remote set-url <remote-server-name> <url>

Просмотр удалённого репозитория.

    git remote show <remote-server-name>


## Отправка данных на сервер

Отправка данных на удалённый сервер.
Если имя удалённого сервера origin, при отправке можно не указывать.
Так же если вы находитесь в ветке, которую требуется отправить, то её можно тоже не указывать.

    git push <remote-server-name> <branch-name>

Удаление удалённой ветки с сервера.

    git push <remote-server-name> --delete <branch-name>


## Скачивание данных с сервера

Скачивание данных с удалённого репозитория.
Так же если вы имеете имя сервера origin, его можно не указывать.

    git pull <remote-server-name> <branch-name>

При отправке данных `git push`, может произойти конфликт,
что на удалённом репозитории уже были добавлены коммиты.
Для этого нужно сначала скачать изменения, и только потом отправить их.

    git pull <remote-server-name> <branch-name>
    git push <remote-server-name> <branch-name>

Если были локальные коммиты, и на удалённом сервере тоже были сделаны коммиты,
то при обычном `pull`, будет сделан мердж-коммит.
Чтобы избавиться от него, требуется использовать опцию `--rebase`.
При этой опции локальный коммит окажется "поверх"
новых коммитов с сервера, а мердж-коммита не будет.

 Если идёт командная работа, то лучше всегда использовать опцию `--rebase`, при взятии изменений.

    git pull --rebase <remote-server-name> <branch-name>


## Загрузка коммитов с сервера

Извлечение всех веток из репозитория.

    git fetch <remote-server-name>

Извлечение определённой ветки.

    git fetch <remote-server-name> <branch-name>

Извлечение всех зарегистрированных удаленных репозиториев и их веток.

    git fetch --all

Опция `--dry-run` выводит на экран действия,
которые были бы выполнены при извлечении, не выполняя их на самом деле.

    git fetch --dry-run

Если после загрузки с определённого сервера появилась новая ветка,
можно её переместить в свою ветку.

    git checkout -b <branch-name> <remote-server-name>/<branch-name>


## Тэги

Тэги позволяют помечать определённые коммиты как важные.
Как правило,используют это для пометки выходящих версий (v1.0 и т.п.).

Просмотр всех тегов.

    git tag

Просмотр тегов по шаблону.

    git tag -l "v1.*"

Есть 2 типа тегов, легковесные и снабженные ком­ментарием
Легковесные это просто указатель на определённый коммит.
С комментарием хранятся в базе уже как полноценный объект.
Они содержат имя человека, поставившего тег, адрес его электронной почты и дату создания и пр.

Создание легковесных тегов.

    git tag <tag-name>

Создание тегов с комментарием.
Если не указать опцию `-m` то открывается редактор, и чтобы ввести тег.

    git tag -a <tag-name> -m "<comment>"

Просмотр определённого тега.

    git show <tag-name>

Так же тэг можно поставить на определённый коммит.

     git tag -a <tag-name> <hash-commit> -m "<commit-tag>"

Отправление тегов на удалённый сервер.

    git push origin <tag-name>

Отправка нескольких тегов сразу.

    git push origin --tags

Удаление тега.

    git tag -d <tag-name>


## Псевдонимы

Можно задавать псевдонимы определённым командам.

Как пример можно задать длинным командам их псевдонимы.

    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status


Так же можно вводить псевдонимы для тех команд которых не хватает.

Например, вывод последнего коммита.

    git config --global alias.last "log -1 HEAD"


## Настройка репозитория

Посмотреть все опции команды.

    git config


Есть 3 уровня конфигурации:
* `--local` - локальный уровень, стоит по умолчанию, применяется к одному текущему репозиторию.
* `--global` - глобальный уровень, применяется к пользователю для всех его репозиториев.
* `--system` - системный уровень, применяется ко всем настройкам машины.
Охватывает всех пользователей операционной системы.

Глобальные настройки для определённого пользователя обычно лежит по пути `~/.gitconfig`.

Команда для просмотра заданных уже настроек.

    git config --list

Команда для просмотра определённой настройки.

    git config user.name

Настройка имени пользователя.

    git config --global user.name "<name>"

Настройка email адреса пользователя.

    git config --global user.email "<email-address>"

Выбор редактора кода по умолчанию.

    git config --global core.editor nvim

Автоматическое исправление опечаток, будет автоматически предложена команда с исправлением.

    git config --global help.autocorrect 1


# Ветвление

## Создание и просмотр веток

Ветвление в git одна из самых важный знаний, для работы с репозиторием.
Ветка - это указатель на определённый коммит.

Показать текущие ветки.

    git branch

Создать ветку от текущей ветки.

    git branch <new-branch>

Создание ветки от определённой ветки.

    git branch <new_branch> <base-branch>

Безопасное удаление ветки, если ветка не смёрджена, то она не будет удалена.

    git branch -d <branch-name>

Принудительное удаление ветки.

    git branch -D <branch-name>

Показать больше текущей информации о ветках, показывает последний сделанный коммит.

    git branch -v

Информация о всех ветках, включая удалённые.

    git branch -a

Просмотр удалённых веток.

    git branch -r

Так же можно использовать опции `--merged` - показывает ветки объединённые с текущей,
и `--no-merged` - ветки которые не слиты в другие ветки.

    git branch --merged
    git branch --no-merged


## Смена ветки

Команда для смены ветки.

    git checkout <branch-name>

Смена веток так же приводит к смене файлов в рабочей директории.

Можно создать ветку и перейти в неё с помощью одной команды.

    git checkout -b <new-branch>


## Слияние

Слияние - соединение двух веток.

Требуется перейти в ветку которую будет происходить мердж и дальше произвести слияние ветки.

    git checkout <branch-name>
    git merge <merged-branch-name>

При объединении двух веток, Git принимает два указателя на коммиты
(обычно последние в ветке) и находит общий для них родительский коммит.
Затем Git создает коммит слияния,
в котором объединяются изменения из обеих последовательностей, выбранных к слиянию.

Конфликты при слиянии.

Процесс слияния далеко не всегда проходит гладко.
Если в двух ветках, которые сливаются, были внесли разные изменения в один и тот же файл,
Git не cможет просто взять и объединить их.
При слиянии появляется конфликт.

Чтобы посмотреть какие файлы имеют конфликт.

    git status

При открытии файла который вызвал конфликт,
система самостоятельно помечает места где вызван конфликт.

Пример:

    <<<<<<< HEAD
    qwerty
    =======
    123456
    >>>>>>> new

И требуется вручную отредактировать файл, и дальше произвести коммит изменений.

Если написать `git commit` то git самостоятельно сгенерирует комментарий о мерже
и останется только подтвердить коммит.

При возникновении конфликта можно отменить слияние.

    git merge --abort

Если шла разработка ветки, и её требуется смержить в другую ветку,
и при этом требуется сохранить ветку без перемотки, нужно использовать опцию `--no-ff`

    git merge --no-ff <branch-name>

Если в ветке было много коммитов, и эти коммиты не требуется отображать в релизе.
Можно применить флаг `--squash`. После этого потребуется указать общий коммит для слияния.

    git merge --squash <branch-name>


## Перемещение

Перемещение веток.
Сначала нужно перейти в ветку которую нужно переместить,
а потом указать ветку в которую перемещаем.

    git checkout <rebased-branch-name>
    git rebase <branch-name>

Так же можно переместить одну ветку в другую, вне зависимости в какой ветке можно находиться.

    git rebase <branch-name> <rebased-branch-name>

При возникновении конфликта перемещения коммитов,
требуется разрешить конфликт и перейти на следующий коммит.

    # разрешить конфликт
    # переход на следующий коммит
    git rebase --continue

После перемещения ветки, так же можно выполнить перемотку ветки от куда происходило перемещение.

    git checkout <branch-name>
    git merge <rebased-branch-name>

И если ветка больше не нужна удалить.

    git branch -d <rebased-branch-name>

При возникновении конфликта можно отменить перемещение.

    git rebase --abort

Варианты команд для rebase.
* `p, pick` - использовать коммит.
* `r, reword` - использовать коммит, но отредактировать сообщение фиксации.
* `e, edit` - использовать коммит, но остановить для внесения поправок.
* `s, squash` - использовать коммит, но объединить с предыдущим коммитом.
* `f, fixup` - как "сквош", но отбросить сообщение журнала этого коммита.
* `x, exec` - выполнить команду (остальная часть строки) с помощью оболочки.
* `d, drop` - удалить коммит.


## Сравнение слияния и перемещение веток

Есть два вида соединения веток - слияние и перемещение, так что же лучше?

`rebase`:

Плюсы:
+ Упрощает историю - при каждом слиянии веток образуется дополнительный коммит о слиянии,
что для истории коммитов плохо.
Так же если слияние происходит часто получается пачка пустых коммитов о слиянии.

Минусы:
- Если работа ведётся не одим человеком,
то может произойти ситуация когда один разработчики переместил ветку выше,
а другой ещё не перешёл на неё и при этом сделал какие-то изменения в старой версии -
очень трудно потом восстанавливаться.
- Возможны ошибки в коммитах - если в старой версии использовался метод *Hello*,
а потом он изменился на *HelloSay* и при этом может не обнаружится этого,
то все коммиты которые были перемещены будут "битые",
так же на них будет очень плохо делать откат.

Это можно частично исправить если есть какие-либо тесты.
Их можно пртестировать перед перемещением, и если будет ошибка то об этом будет сообщаться,
и rebase будет ждать действий для исправления.

    git rebase -x '...' master

`merge`:

Плюсы:
+ При мердже и не плохом коммите, будет повреждён только один коммит,
и при этом оставшиеся коммиты будут целы.

Минусы:
- При многочисленном мердже появляется куча бесполезных коммитов,
что затрудняет историю коммитов и разработку.

Использовать `rebase` и `merge` нужно в правильных ситуациях.
Считается что rebase для приватных веток, когда изменения не выложены,
и не будет конфликтов с другими разработчиками при перебазировании.
А merge лучше использовать когда уже над веткой работают несколько разработчиков.


# Инструменты Git

## Редактирование нескольких коммитов

Команда для того чтобы отредактировать более ранний коммит или коммиты.

    git rebase -i HEAD~3

В данном случае будут показаны последние 3 коммита для редактирования
в обратном порядке - сначала старые, потом новые.
После ввода команды, открывается текстовый редактор.

Для редактирования определённого коммита, заменить `pick` на `edit`,
дальше сохранить документ, и дальше будут показаны текущая инструкция.

Для редактирования текущего коммита.

        git commit --amend

Для перехода на следующий коммит.

        git rebase --continue

Во время `edit` можно менять файлы и добавлять в изменённые коммиты.

Для редактирования только сообщения коммита, можно заменить `pick` на `reword`,
и в данном случае будет открываться сразу текстовый редактор, для изменения коммитов.


## Объединение коммитов

Сначала нужно вывести какие коммиты нужно объединить.

    git rebase -i HEAD~5

Для того чтобы объединить коммит с предыдущим нужно заменить `pick` на `squash`.
Дальше откроется редактор, в котором нужно указать только один коммит,
на который они все изменятся.

Было:

    # This is a combination of 3 commits.
    # The first commit's message is:

    commit 1

    # This is the 2nd commit message:

    commit 2

    # This is the 3rd commit message:

    commit 3

Стало:

    commit squash

Всё что помечено "#" является комментарием.


## Изменение порядка следования коммитов

Для изменения порядка следования коммитов, так же применяется `rebase`.
Для начала требуется открыть список коммитов, которые мы хотим изменить.

    git rebase -i HEAD~5

И внутри уже просто поменять местами коммиты которые нам нужны.

Было:

    pick 1e09d8d commit 1
    pick a747cf7 commit 2
    pick 914847a commit 3

Стало:

    pick 1e09d8d commit 1
    pick 914847a commit 3
    pick a747cf7 commit 2

Но если в коммитах были какие-то общие изменения,
то будет конфликт, который нужно будет решить.

Либо же можно отменить изменения.

    git rebase --abort


## Отмена коммитов

reset - универсальный инструмент для отмены изменений.

По умолчанию при вызове команды `git reset`
используются неявные аргументы `--mixed` и `HEAD`.

Поэтому эти две команды одинаковы.

    git reset
    git reset --mixed HEAD~

--soft:

При этой опции, отменяются коммиты, до указанного, но при этом файлы,
которые были изменены в этих коммитах, остаются и все их изменения.
И так же они добавлены в отслеживаемые файлы.

    git reset --soft HEAD~2

--mixed:

При этой опции, отменяются коммиты, до указанного,
изменённые файлы сохраняются, но не добавлены в отслеживаемые.

    git reset --mixed HEAD~2

--hard:

Самая опасная команда в git.
При её использовании теряются все коммиты и данные невозвратно.
И восстановить эти данные просто невозможно.

    git reset --hard HEAD~2

Если требуется удалить коммит с удалённого репозитория,
то требуется откатиться сначала на локальном репозитории,
и дальше отправить их на удалённый.

    git reset --hard HEAD~1
    git push --force


## Отмена изменений при уже отправленном коммите

Если коммит уже был сделан и отправлен коллегам,
то удалять такой коммит будет не лучшим решением.
Т.к. далее уже на его основе могут быть сделаны изменения других людей.

Для того чтобы исправить такую ситуацию, можно использовать `revert`.
Он делает новый коммит который отменяет все сделанные изменения.
С одной стороны это очень плохо - загрязняет историю,
но с другой, может быть одним из выходов в данной ситуации.

Отмена последнего коммита.

    git revert HEAD

Отменить любой коммит можно по хэшу коммита,
но может случиться конфликт, который потребуется решить самостоятельно.

    git revert <hash-commit>

Можно отменять несколько коммитов.

    git revert <hash-commit-1>..<hash-commit-3>

Если требуется посмотреть изменения предыдущих коммитов,
но не делать коммит о отмене, можно воспользоваться флагом `-n`.

    git revert -n <hash-commit>


## Перенос указателя ветки

Принудительный перенос ветки на определенный коммит.

    git branch -f <branch-name> <hash-commit>

Либо же если нужно перенести ветку на другую ветку,
сначала указывается ветка которую переносим, потом на какую переносим.
Так же вместо ветки можно указать коммит.

     git checkout -B <branch-name-1> <branch-name-2>
     git checkout -B <branch-name> <hash-commit>


## Очистка проекта от лишних файлов

Команда `clean` предназначена только для удаления неотслеживаемых файлов и директорий.

Популярные опции для `clean`
* -d - удалялись не только файлы но и директории
* -x - удалялись файлы, которые игнорируются через .gitignore
* -f - принудительное удаление
* -n - предварительный запуск, показывает какие файлы будут удалены


## Просмотр кто написал эту строку

Для полного просмотра кто написал каждую строчку в файле.

    git blame <file-name>

Опция `-L` позволяет указать диапазон строк.

    git blame -L 1,5 <file-name>

Опция `-e` позволяет отобразить адреса электронной почты авторов вместо имен пользователей.

    git blame -e <file-name>

Опция `-M` позволяет находить перемещённые или скопированные
строки внутри одного и того же файла.
Указываться будет первоначальный автор строк.

    git blame -M <file-name>

Опция `-C` позволяет находить строки,
которые были перемещены или скопированы из других файлов.

    git blame -C README.md


## Восстановление файла к определённому коммиту

Если файл был удалён или изменён и требуется вернуть его к последнему коммиту.

    git restore <file-name>

Для возвращение файла к определённому коммиту.

    git restore --source=<hash-commit> <file-name>

Чтобы убрать файл из отслеживаемых файлов, но не убирать его изменения.

    git restore --staged <file-name>


## Откладывание изменений

Если были сделаны изменения в файлах, и нужно изменить ветку,
при этом не сделав коммит, можно воспользоваться операцией `stash`.
Операция stash берёт изменённые файлы каталога и сохраняет их в хранилище,
которые можно применить в любое время.

Для того чтобы припрятать изменения, после этого можно увидеть что изменений нет.

    git stash

Чтобы посмотреть список припрятанных изменений.

    git stash list

Чтобы вернуть припрятанные изменения.
При этом внесённые изменения будут оставаться в хранилище даже после возвращения.

    git stash apply stash@{<index>}

C опцией `--index`, команда попытается восстановить изменения в индексе.

    git stash apply --index stash@{<index>}

Для удаления изменения из хранилища.

    git stash drop stash@{<index>}

Для того чтобы вернуть изменения и сразу удалить из архива используется команда.

    git stash pop stash@{<index>}

При опции `--keep-index` будут припрятаны изменения,
но и при этом будут оставлены в индексе.

    git stash --keep-index

При опции `--include-untracked` или `-u`, будут спрятаны так же и все не отслеживаемые файлы.

    git stash --include-untracked
    git stash -u

При опции `--patch`, будет запущен интерактивный режим,
в котором по каждому файлу спросят, нужно ли его припрятать или нет.

    git stash --patch

Так же можно изменения вынести в новую ветку.

    git stash branch <new-branch-name> stash@{<index>}

Удаление всех спрятанных изменений.

    git stash clear


## Копирование коммита

Команда `cherry-pick` позволяет скопировать один коммит
из другой ветки и вставить его в текущую.
В качестве параметра передаётся идентификатор коммита в другой ветке.

    git cherry-pick <hash-commit>

## Подключение к репозиторию по ssh
Сначала требуется сгенерировать ssh ключ.
Сначала попросят ввести имя ssh ключа, его можно оставить по умолчанию.
А дальше попросят ввести кодовую фразу, можно не вводить и просто нажать enter.

    ssh-keygen

Ключ обычно хранится в директории ~/.ssh, по умолчанию его имя id_rsa.
Генерируется два ключа открытый - id_rsa.pub, и закрытый - id_rsa.
Сообщать можно только открытый ключ.

Для того чтобы передать ssh ключ github,
нужно зайти на github.com, Settings, SSH and GPG keys,
New SSH Key, в Title - ввести описание ключа, Key - ввести публичный ключ.
И после этого можно пушить коммиты без постоянного потверждения.

Если GitHub репозиторий изначально был подключен по web URL,
то требуется его поменять на ssh URL.

    git remote set-url <remote-server-name> <ssh-url>


## Быстрый поиск плохого коммита

Если в какой-то момент оказалось,
что какие-то тесты не закпускаются или какая-то часть кода перестала правильно работать,
но при этом было сделано довольно много коммитов,
отыскать где была допущена ошибка может быть пробематично.
Команда `bisect` позволяет найти очень быстро плохой коммит.

Для старта поиска нужно запустить bisect.

    git bisect start

Дальше требуется указать хороший коммит и плохой коммит.

    git bisect bad <hash-commit>
    git bisect good <hash-commit>


После этого, bisect разделит все коммиты, которые располагаются между ними пополам,
переключится в новую (безымянную) ветку на этом срединном коммите и позволит вам проверить,
работает ли в нём нужный код.

Сказать что в данном коммите не работает нужный код.

    git bisect bad

Сказать что в данном коммите работает нужный код.

    git bisect good

Остановить поиск, и вернуться к начальной точке.

    git bisect reset

Просмотр последнего успешно выполненного bisect.

    git bisect log


## Отмена любых изменений

С помощью `reflog` можно восстановить любые изменения веток, даже reset --hard.

Команда для просмотра изменений которые были совершены.

    git reflog

Вывод изменений определённой ветки.

    git reflog <branch-name>

Так же можно вывести в привычном формате reflog.

    git log -g

Дальше по выведенным логам можно понять какие изменения были,
и после этого вернуть изменения.
После этой команды, он перейдет на этот коммит,
и дальше уже можно будет решить как вернуть изменения.

    git checkout <hash-reflog>

Так же можно эти изменения перенести в ветку для удобства.

    git branch <recover-branch> <hash-reflog>

Данные о reflog остаются только локально,
и при отправке на удалённый сервер они не будут сохранены на нём.

Стоит учитывать, что обычные записи хранятся 90 дней, если же коммит не достижим,
к примеру удалена ветка, изменения будут хранится только 30 дней.
Конфигурацию хранения логов можно поменять.


## Подмодули

При работе с проектом, возникает необходимость использовать в нем другой проект.
При этом нужно продолжать работать с двумя проектами по отдельности,
но при этом использовать один из них в другом.

Добавление подмодуля.

    git submodule add <url-repository>

При клонировании репозитория с подмодулями.

    # для инициализации локального конфигурационного файла
    git submodule init
    # для получения всех данных этого проекта
    git submodule update

Но можно сделать это более просто, передать git clone флаг `--recurse-submodules`.

    git clone --recurse-submodules <url-repository>

Команда git pull получает изменения для подмодулей, но она не обновляет подмодули.
Поэтому нужно обновить подмодули, и лучше запускать submodule update с параметром `--init`,
чтобы проинициализировать новые подмодули, а так же с параметром `--recursive`,
чтобы обновить вложенные подмодули.

    git pull
    git submodule update --init --recursive

Если установить параметр конфигурации status.submodulesummary,
при git status будет так же показываться сводка по подмодулям.

    git config status.submodulesummary 1
    git status

Если требуется чтобы подмодуль отслеживал только нужную ветку.

    git config -f .gitmodules submodule.Repoitory.branch <branch-name>

Отправка изменений не только из основного модуля, а так же из подмодуля.

При значении `check`, push просто завершится ошибкой,
если какой-то из подмодулей не был отправлен на сервер.
И тогда нужно будет вручную проходиться и оправлять изменения на сервер.

    git push --recurse-submodules=check

При значении `on-demand`, будет пытаться отправлять самостоятельно без помощи пользователя.

    git push --recurse-submodules=on-demand

Так же можно установить такое поведение по умолчанию.

    git config push.recurseSubmodules check
    # или
    git config push.recurseSubmodules on-demand


## Подпись коммитов

Для подписи коммитов используется утилита `gpg`.

Для того чтобы получить список имеющихся GPG-ключей.

    gpg --list-keys

Для генерации ключа.

    gpg --gen-key

При генерации нужно написать своё имя, email адрес.
И далее нужно установить пароль для защиты ключа,
так же можно оставить поле пустым и не указывать пароль.

Команда для более полной настройки ключа.
Можно указать тип ключа, размер ключа и время работы ключа.

    gpg --full-gen-key

Для того чтобы подписи коммитов были автоматически.

    git config --global commit.gpgsign true

Если ключей несколько, можно установить определённый ключ.

    git config --global user.signingkey <hash-pub-key>

Для загрузки открытого ключа на GitHub, нужно его экспортировать.
Для записи его на GitHub нужно перейти в Settings, и далее SSH and GPG keys.

    gpg --export --armor <hash-key> > ~/gpg-key.pub

Команда для сохранения резервной копии привтного ключа.

    gpg --export-secret-keys --armor <hash-key> > ./gpg-key.asc

Для подписи тегов вместо флага `-a` используется флаг `-s`.

    git tag -s <tag-name> -m "<comment>"

Так же при просмотре тега видно подпись.

    git show <tag-name>

Для проверки подписанного тега. Для ее корректной работы нужно,
чтобы в хранилище ключей присутствовал открытый ключ автора, поставeвшего подпись.

    git tag -v <tag-name>

Для подписи коммитов используется флаг `-S`.

    git commit -a -S -m "<comment>"

Для просмотра и проверки подписей есть параметр `--show-signature`.

    git log --show-signature

Команды `merge` и `pull` можно заставить проверять и отклонять слияния,
если коммит не содержит доверенной GPG подписи с помощью опции `--verify-signatures`.

При слиянии, если один из коммитов не будет подписан будет выдана ошибка при слияни.

    git merge --verify-signatures <branch-name>

Если сливаемая ветка содержит только корректно подписанные коммиты,
команда слияния сначала покажет все проверенные подписи, а затем выполнит слияние.

Так же если использовать флаг `-S` при слиянии, то коммит так же будет подписан.

    git merge --verify-signatures -S <branch-name>

Для удаления ключа используется сначала удаление приватного ключа.

    gpg --delete-secret-keys <name-user>

А после можно удалить уже сам ключ.

    gpg --delete-keys <name-user>

Подписывать коммиты должен каждый,
но при этом каждый коллега в команде должен уметь подписывать их.


## Поиск по истории коммитов

Для поиска строк по коммитам используется команда `git grep`.
git grep принимает многие ключи, что и утилита grep в Linux.

Для поиска строки в git репозитории.

    git grep <search-string>

Для того чтобы показать на какой строке найденный паттерн,
используется опция `-n` или `--line-number`.

    git grep -n <search-string>

Для того чтобы показать количество найденных параметров,
используется опция `-c` или `--count`.

    git grep -c <search-string>

Для более удобного вывода можно использовать опции
`--break` - вывести пустую строку между совпадениями из разных файлов, и
`--heading` - показывать имя файла над совпадениями в этом файле,
а не в начале каждой отображаемой строки.

    git grep --break --heading <search-string>

Поиск строки включая git подмодули:

    git grep --recurse-submodules <search-string>

Поиск строки в файлах, подходящих под указанный шаблон:

    git grep <search-string> -- <search-files>

Поиск по строке внутри указанного коммита

    git grep <search-string> <hash-commit>

`-e` - поиск по нескольким параметрам.

    git grep -e <search-string-1> -e <search-string-2>

Так же можно использовать дополнительные параметры `--and`, `--or` и `--not`,
для сочетания нескольких шаблонов.

Если нужно найти когда было добавлено или удалено
выражение можно использовать `git log` c флагом `-S`.

    git log -S <search-string>

Так же есть поиск по журналу изменений строки.
Для этого используется git log с флагом `-L`.

Можно либо указать диапазон строк и файл `<start>,<end>:<file>`,
либо по регулярному выражению и файлу `:<pattern>:<file>`.

*Примеры:*

    git log -L 4,6:file_test

    git log -L :pattern:file_test


## Повторное слияние

Команда `git rerere` -
это сокращение для reuse recorded resolution (повторно использовать сохранённое решение).

Эта команда позволяет попросить Git запомнить как была разрешёна некоторая часть конфликта,
и в случае возникновения такого же конфликта, Git сможет его разрешить автоматически.

Команда для включения rerere.

    git config --global rerere.enabled true

Просмотр какие снимки состояния сохранены.

    git rerere status

Показать текущее состояние разрешения конфликта.

    git rerere diff


